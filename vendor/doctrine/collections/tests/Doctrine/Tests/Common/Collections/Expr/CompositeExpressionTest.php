<?php
 namespace Doctrine\Tests\Common\Collections\Expr; use Doctrine\Common\Collections\Expr\CompositeExpression; use Doctrine\Common\Collections\Expr\ExpressionVisitor; use Doctrine\Common\Collections\Expr\Value; use PHPUnit\Framework\TestCase as TestCase; class CompositeExpressionTest extends TestCase { public function invalidDataProvider() { return array( array( 'expression' => new Value('value'), ), array( 'expression' => 'wrong-type', ), ); } public function testExceptions($expression) { $type = CompositeExpression::TYPE_AND; $expressions = array( $expression, ); $this->setExpectedException('\RuntimeException'); new CompositeExpression($type, $expressions); } public function testGetType() { $compositeExpression = $this->createCompositeExpression(); $expectedType = CompositeExpression::TYPE_AND; $actualType = $compositeExpression->getType(); $this->assertSame($expectedType, $actualType); } protected function createCompositeExpression() { $type = CompositeExpression::TYPE_AND; $expressions = array( $this->createMock('Doctrine\Common\Collections\Expr\Expression'), ); $compositeExpression = new CompositeExpression($type, $expressions); return $compositeExpression; } public function testGetExpressionList() { $compositeExpression = $this->createCompositeExpression(); $expectedExpressionList = array( $this->createMock('Doctrine\Common\Collections\Expr\Expression'), ); $actualExpressionList = $compositeExpression->getExpressionList(); $this->assertEquals($expectedExpressionList, $actualExpressionList); } public function testVisitor() { $compositeExpression = $this->createCompositeExpression(); $visitor = $this->getMockForAbstractClass('Doctrine\Common\Collections\Expr\ExpressionVisitor'); $visitor ->expects($this->once()) ->method('walkCompositeExpression'); $compositeExpression->visit($visitor); } }
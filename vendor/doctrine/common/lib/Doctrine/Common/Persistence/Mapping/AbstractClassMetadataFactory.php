<?php
 namespace Doctrine\Common\Persistence\Mapping; use Doctrine\Common\Cache\Cache; use Doctrine\Common\Util\ClassUtils; use ReflectionException; abstract class AbstractClassMetadataFactory implements ClassMetadataFactory { protected $cacheSalt = '$CLASSMETADATA'; private $cacheDriver; private $loadedMetadata = []; protected $initialized = false; private $reflectionService = null; public function setCacheDriver(Cache $cacheDriver = null) { $this->cacheDriver = $cacheDriver; } public function getCacheDriver() { return $this->cacheDriver; } public function getLoadedMetadata() { return $this->loadedMetadata; } public function getAllMetadata() { if ( ! $this->initialized) { $this->initialize(); } $driver = $this->getDriver(); $metadata = []; foreach ($driver->getAllClassNames() as $className) { $metadata[] = $this->getMetadataFor($className); } return $metadata; } abstract protected function initialize(); abstract protected function getFqcnFromAlias($namespaceAlias, $simpleClassName); abstract protected function getDriver(); abstract protected function wakeupReflection(ClassMetadata $class, ReflectionService $reflService); abstract protected function initializeReflection(ClassMetadata $class, ReflectionService $reflService); abstract protected function isEntity(ClassMetadata $class); public function getMetadataFor($className) { if (isset($this->loadedMetadata[$className])) { return $this->loadedMetadata[$className]; } if (strpos($className, ':') !== false) { list($namespaceAlias, $simpleClassName) = explode(':', $className, 2); $realClassName = $this->getFqcnFromAlias($namespaceAlias, $simpleClassName); } else { $realClassName = ClassUtils::getRealClass($className); } if (isset($this->loadedMetadata[$realClassName])) { return $this->loadedMetadata[$className] = $this->loadedMetadata[$realClassName]; } $loadingException = null; try { if ($this->cacheDriver) { if (($cached = $this->cacheDriver->fetch($realClassName . $this->cacheSalt)) instanceof ClassMetadata) { $this->loadedMetadata[$realClassName] = $cached; $this->wakeupReflection($cached, $this->getReflectionService()); } else { foreach ($this->loadMetadata($realClassName) as $loadedClassName) { $this->cacheDriver->save( $loadedClassName . $this->cacheSalt, $this->loadedMetadata[$loadedClassName], null ); } } } else { $this->loadMetadata($realClassName); } } catch (MappingException $loadingException) { if (! $fallbackMetadataResponse = $this->onNotFoundMetadata($realClassName)) { throw $loadingException; } $this->loadedMetadata[$realClassName] = $fallbackMetadataResponse; } if ($className !== $realClassName) { $this->loadedMetadata[$className] = $this->loadedMetadata[$realClassName]; } return $this->loadedMetadata[$className]; } public function hasMetadataFor($className) { return isset($this->loadedMetadata[$className]); } public function setMetadataFor($className, $class) { $this->loadedMetadata[$className] = $class; } protected function getParentClasses($name) { $parentClasses = []; foreach (array_reverse($this->getReflectionService()->getParentClasses($name)) as $parentClass) { if ( ! $this->getDriver()->isTransient($parentClass)) { $parentClasses[] = $parentClass; } } return $parentClasses; } protected function loadMetadata($name) { if ( ! $this->initialized) { $this->initialize(); } $loaded = []; $parentClasses = $this->getParentClasses($name); $parentClasses[] = $name; $parent = null; $rootEntityFound = false; $visited = []; $reflService = $this->getReflectionService(); foreach ($parentClasses as $className) { if (isset($this->loadedMetadata[$className])) { $parent = $this->loadedMetadata[$className]; if ($this->isEntity($parent)) { $rootEntityFound = true; array_unshift($visited, $className); } continue; } $class = $this->newClassMetadataInstance($className); $this->initializeReflection($class, $reflService); $this->doLoadMetadata($class, $parent, $rootEntityFound, $visited); $this->loadedMetadata[$className] = $class; $parent = $class; if ($this->isEntity($class)) { $rootEntityFound = true; array_unshift($visited, $className); } $this->wakeupReflection($class, $reflService); $loaded[] = $className; } return $loaded; } protected function onNotFoundMetadata($className) { return null; } abstract protected function doLoadMetadata($class, $parent, $rootEntityFound, array $nonSuperclassParents); abstract protected function newClassMetadataInstance($className); public function isTransient($class) { if ( ! $this->initialized) { $this->initialize(); } if (strpos($class, ':') !== false) { list($namespaceAlias, $simpleClassName) = explode(':', $class, 2); $class = $this->getFqcnFromAlias($namespaceAlias, $simpleClassName); } return $this->getDriver()->isTransient($class); } public function setReflectionService(ReflectionService $reflectionService) { $this->reflectionService = $reflectionService; } public function getReflectionService() { if ($this->reflectionService === null) { $this->reflectionService = new RuntimeReflectionService(); } return $this->reflectionService; } } 
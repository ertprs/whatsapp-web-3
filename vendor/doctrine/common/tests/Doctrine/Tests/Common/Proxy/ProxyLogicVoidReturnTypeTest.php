<?php
 namespace Doctrine\Tests\Common\Proxy; use Doctrine\Common\Proxy\ProxyGenerator; use Doctrine\Common\Proxy\Proxy; use Doctrine\Common\Proxy\Exception\UnexpectedValueException; use Doctrine\Common\Persistence\Mapping\ClassMetadata; use PHPUnit_Framework_TestCase; use stdClass; class ProxyLogicVoidReturnTypeTest extends PHPUnit_Framework_TestCase { protected $proxyLoader; protected $lazyLoadableObjectMetadata; protected $lazyObject; protected $initializerCallbackMock; public function setUp() { if (PHP_VERSION_ID < 70100) { $this->markTestSkipped('Void return type is only supported in PHP >= 7.1.0.'); } $this->proxyLoader = $loader = $this->getMockBuilder(stdClass::class)->setMethods(['load'])->getMock(); $this->initializerCallbackMock = $this->getMockBuilder(stdClass::class)->setMethods(['__invoke'])->getMock(); $this->lazyLoadableObjectMetadata = $metadata = new LazyLoadableObjectWithVoidClassMetadata(); $proxyClassName = 'Doctrine\Tests\Common\ProxyProxy\__CG__\Doctrine\Tests\Common\Proxy\LazyLoadableObjectWithVoid'; if (!class_exists($proxyClassName, false)) { $proxyGenerator = new ProxyGenerator(__DIR__ . '/generated', __NAMESPACE__ . 'Proxy', true); $proxyFileName = $proxyGenerator->getProxyFileName($metadata->getName()); $proxyGenerator->generateProxyClass($metadata, $proxyFileName); require_once $proxyFileName; } $this->lazyObject = new $proxyClassName($this->getClosure($this->initializerCallbackMock)); $this->assertFalse($this->lazyObject->__isInitialized()); } public function testParentVoidMethodIsCalledWithoutParameters() { $this->configureInitializerMock( 1, [$this->lazyObject, 'incrementingAndReturningVoid', []], function () {} ); $this->assertNull($this->lazyObject->incrementingAndReturningVoid()); $this->assertSame(1, $this->lazyObject->value); } public function testParentVoidMethodIsCalledWithParameters() { $this->configureInitializerMock( 1, [$this->lazyObject, 'addingAndReturningVoid', [10]], function () {} ); $this->assertNull($this->lazyObject->addingAndReturningVoid(10)); $this->assertSame(10, $this->lazyObject->value); } private function getClosure($callable) { return function () use ($callable) { call_user_func_array($callable, func_get_args()); }; } private function configureInitializerMock( $expectedCallCount = 0, array $callParamsMatch = null, \Closure $callbackClosure = null ) { if (!$expectedCallCount) { $invocationCountMatcher = $this->exactly((int) $expectedCallCount); } else { $invocationCountMatcher = $expectedCallCount < 0 ? $this->any() : $this->exactly($expectedCallCount); } $invocationMocker = $this->initializerCallbackMock->expects($invocationCountMatcher)->method('__invoke'); if (null !== $callParamsMatch) { call_user_func_array([$invocationMocker, 'with'], $callParamsMatch); } if ($callbackClosure) { $invocationMocker->will($this->returnCallback($callbackClosure)); } } } 
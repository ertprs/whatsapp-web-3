<?php
 namespace Doctrine\DBAL\Driver\IBMDB2; use Doctrine\DBAL\Driver\Statement; class DB2Statement implements \IteratorAggregate, Statement { private $_stmt = null; private $_bindParam = array(); private $defaultFetchClass = '\stdClass'; private $defaultFetchClassCtorArgs = array(); private $_defaultFetchMode = \PDO::FETCH_BOTH; private $result = false; static private $_typeMap = array( \PDO::PARAM_INT => DB2_LONG, \PDO::PARAM_STR => DB2_CHAR, ); public function __construct($stmt) { $this->_stmt = $stmt; } public function bindValue($param, $value, $type = null) { return $this->bindParam($param, $value, $type); } public function bindParam($column, &$variable, $type = null, $length = null) { $this->_bindParam[$column] =& $variable; if ($type && isset(self::$_typeMap[$type])) { $type = self::$_typeMap[$type]; } else { $type = DB2_CHAR; } if (!db2_bind_param($this->_stmt, $column, "variable", DB2_PARAM_IN, $type)) { throw new DB2Exception(db2_stmt_errormsg()); } return true; } public function closeCursor() { if ( ! $this->_stmt) { return false; } $this->_bindParam = array(); if (!db2_free_result($this->_stmt)) { return false; } $this->result = false; return true; } public function columnCount() { if ( ! $this->_stmt) { return false; } return db2_num_fields($this->_stmt); } public function errorCode() { return db2_stmt_error(); } public function errorInfo() { return array( 0 => db2_stmt_errormsg(), 1 => db2_stmt_error(), ); } public function execute($params = null) { if ( ! $this->_stmt) { return false; } if ($params === null) { ksort($this->_bindParam); $params = array(); foreach ($this->_bindParam as $column => $value) { $params[] = $value; } } $retval = @db2_execute($this->_stmt, $params); if ($retval === false) { throw new DB2Exception(db2_stmt_errormsg()); } $this->result = true; return $retval; } public function setFetchMode($fetchMode, $arg2 = null, $arg3 = null) { $this->_defaultFetchMode = $fetchMode; $this->defaultFetchClass = $arg2 ? $arg2 : $this->defaultFetchClass; $this->defaultFetchClassCtorArgs = $arg3 ? (array) $arg3 : $this->defaultFetchClassCtorArgs; return true; } public function getIterator() { $data = $this->fetchAll(); return new \ArrayIterator($data); } public function fetch($fetchMode = null) { if (!$this->result) { return false; } $fetchMode = $fetchMode ?: $this->_defaultFetchMode; switch ($fetchMode) { case \PDO::FETCH_BOTH: return db2_fetch_both($this->_stmt); case \PDO::FETCH_ASSOC: return db2_fetch_assoc($this->_stmt); case \PDO::FETCH_CLASS: $className = $this->defaultFetchClass; $ctorArgs = $this->defaultFetchClassCtorArgs; if (func_num_args() >= 2) { $args = func_get_args(); $className = $args[1]; $ctorArgs = isset($args[2]) ? $args[2] : array(); } $result = db2_fetch_object($this->_stmt); if ($result instanceof \stdClass) { $result = $this->castObject($result, $className, $ctorArgs); } return $result; case \PDO::FETCH_NUM: return db2_fetch_array($this->_stmt); case \PDO::FETCH_OBJ: return db2_fetch_object($this->_stmt); default: throw new DB2Exception("Given Fetch-Style " . $fetchMode . " is not supported."); } } public function fetchAll($fetchMode = null) { $rows = array(); switch ($fetchMode) { case \PDO::FETCH_CLASS: while ($row = call_user_func_array(array($this, 'fetch'), func_get_args())) { $rows[] = $row; } break; case \PDO::FETCH_COLUMN: while ($row = $this->fetchColumn()) { $rows[] = $row; } break; default: while ($row = $this->fetch($fetchMode)) { $rows[] = $row; } } return $rows; } public function fetchColumn($columnIndex = 0) { $row = $this->fetch(\PDO::FETCH_NUM); if (false === $row) { return false; } return isset($row[$columnIndex]) ? $row[$columnIndex] : null; } public function rowCount() { return (@db2_num_rows($this->_stmt))?:0; } private function castObject(\stdClass $sourceObject, $destinationClass, array $ctorArgs = array()) { if ( ! is_string($destinationClass)) { if ( ! is_object($destinationClass)) { throw new DB2Exception(sprintf( 'Destination class has to be of type string or object, %s given.', gettype($destinationClass) )); } } else { $destinationClass = new \ReflectionClass($destinationClass); $destinationClass = $destinationClass->newInstanceArgs($ctorArgs); } $sourceReflection = new \ReflectionObject($sourceObject); $destinationClassReflection = new \ReflectionObject($destinationClass); $destinationProperties = array_change_key_case($destinationClassReflection->getProperties(), \CASE_LOWER); foreach ($sourceReflection->getProperties() as $sourceProperty) { $sourceProperty->setAccessible(true); $name = $sourceProperty->getName(); $value = $sourceProperty->getValue($sourceObject); if ($destinationClassReflection->hasProperty($name)) { $destinationProperty = $destinationClassReflection->getProperty($name); $destinationProperty->setAccessible(true); $destinationProperty->setValue($destinationClass, $value); continue; } $name = strtolower($name); if (isset($destinationProperties[$name])) { $destinationProperty = $destinationProperties[$name]; $destinationProperty->setAccessible(true); $destinationProperty->setValue($destinationClass, $value); continue; } $destinationClass->$name = $value; } return $destinationClass; } } 
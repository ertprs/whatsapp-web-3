<?php
 namespace Doctrine\DBAL\Driver\Mysqli; use Doctrine\DBAL\Driver\Connection as Connection; use Doctrine\DBAL\Driver\PingableConnection; use Doctrine\DBAL\Driver\ServerInfoAwareConnection; class MysqliConnection implements Connection, PingableConnection, ServerInfoAwareConnection { const OPTION_FLAGS = 'flags'; private $_conn; public function __construct(array $params, $username, $password, array $driverOptions = array()) { $port = isset($params['port']) ? $params['port'] : ini_get('mysqli.default_port'); if ( ! $port) { $port = 3306; } $socket = isset($params['unix_socket']) ? $params['unix_socket'] : ini_get('mysqli.default_socket'); $dbname = isset($params['dbname']) ? $params['dbname'] : null; $flags = isset($driverOptions[static::OPTION_FLAGS]) ? $driverOptions[static::OPTION_FLAGS] : null; $this->_conn = mysqli_init(); $this->setDriverOptions($driverOptions); set_error_handler(function () {}); if ( ! $this->_conn->real_connect($params['host'], $username, $password, $dbname, $port, $socket, $flags)) { restore_error_handler(); throw new MysqliException($this->_conn->connect_error, @$this->_conn->sqlstate ?: 'HY000', $this->_conn->connect_errno); } restore_error_handler(); if (isset($params['charset'])) { $this->_conn->set_charset($params['charset']); } } public function getWrappedResourceHandle() { return $this->_conn; } public function getServerVersion() { $majorVersion = floor($this->_conn->server_version / 10000); $minorVersion = floor(($this->_conn->server_version - $majorVersion * 10000) / 100); $patchVersion = floor($this->_conn->server_version - $majorVersion * 10000 - $minorVersion * 100); return $majorVersion . '.' . $minorVersion . '.' . $patchVersion; } public function requiresQueryForServerVersion() { return false; } public function prepare($prepareString) { return new MysqliStatement($this->_conn, $prepareString); } public function query() { $args = func_get_args(); $sql = $args[0]; $stmt = $this->prepare($sql); $stmt->execute(); return $stmt; } public function quote($input, $type=\PDO::PARAM_STR) { return "'". $this->_conn->escape_string($input) ."'"; } public function exec($statement) { if (false === $this->_conn->query($statement)) { throw new MysqliException($this->_conn->error, $this->_conn->sqlstate, $this->_conn->errno); } return $this->_conn->affected_rows; } public function lastInsertId($name = null) { return $this->_conn->insert_id; } public function beginTransaction() { $this->_conn->query('START TRANSACTION'); return true; } public function commit() { return $this->_conn->commit(); } public function rollBack() { return $this->_conn->rollback(); } public function errorCode() { return $this->_conn->errno; } public function errorInfo() { return $this->_conn->error; } private function setDriverOptions(array $driverOptions = array()) { $supportedDriverOptions = array( \MYSQLI_OPT_CONNECT_TIMEOUT, \MYSQLI_OPT_LOCAL_INFILE, \MYSQLI_INIT_COMMAND, \MYSQLI_READ_DEFAULT_FILE, \MYSQLI_READ_DEFAULT_GROUP, ); if (defined('MYSQLI_SERVER_PUBLIC_KEY')) { $supportedDriverOptions[] = \MYSQLI_SERVER_PUBLIC_KEY; } $exceptionMsg = "%s option '%s' with value '%s'"; foreach ($driverOptions as $option => $value) { if ($option === static::OPTION_FLAGS) { continue; } if (!in_array($option, $supportedDriverOptions, true)) { throw new MysqliException( sprintf($exceptionMsg, 'Unsupported', $option, $value) ); } if (@mysqli_options($this->_conn, $option, $value)) { continue; } $msg = sprintf($exceptionMsg, 'Failed to set', $option, $value); $msg .= sprintf(', error: %s (%d)', mysqli_error($this->_conn), mysqli_errno($this->_conn)); throw new MysqliException( $msg, $this->_conn->sqlstate, $this->_conn->errno ); } } public function ping() { return $this->_conn->ping(); } } 
<?php
 namespace Doctrine\DBAL\Schema; use Doctrine\DBAL\Platforms\AbstractPlatform; class ForeignKeyConstraint extends AbstractAsset implements Constraint { protected $_localTable; protected $_localColumnNames; protected $_foreignTableName; protected $_foreignColumnNames; protected $_options; public function __construct(array $localColumnNames, $foreignTableName, array $foreignColumnNames, $name = null, array $options = array()) { $this->_setName($name); $identifierConstructorCallback = function ($column) { return new Identifier($column); }; $this->_localColumnNames = $localColumnNames ? array_combine($localColumnNames, array_map($identifierConstructorCallback, $localColumnNames)) : array(); if ($foreignTableName instanceof Table) { $this->_foreignTableName = $foreignTableName; } else { $this->_foreignTableName = new Identifier($foreignTableName); } $this->_foreignColumnNames = $foreignColumnNames ? array_combine($foreignColumnNames, array_map($identifierConstructorCallback, $foreignColumnNames)) : array(); $this->_options = $options; } public function getLocalTableName() { return $this->_localTable->getName(); } public function setLocalTable(Table $table) { $this->_localTable = $table; } public function getLocalTable() { return $this->_localTable; } public function getLocalColumns() { return array_keys($this->_localColumnNames); } public function getQuotedLocalColumns(AbstractPlatform $platform) { $columns = array(); foreach ($this->_localColumnNames as $column) { $columns[] = $column->getQuotedName($platform); } return $columns; } public function getUnquotedLocalColumns() { return array_map(array($this, 'trimQuotes'), $this->getLocalColumns()); } public function getUnquotedForeignColumns() { return array_map(array($this, 'trimQuotes'), $this->getForeignColumns()); } public function getColumns() { return $this->getLocalColumns(); } public function getQuotedColumns(AbstractPlatform $platform) { return $this->getQuotedLocalColumns($platform); } public function getForeignTableName() { return $this->_foreignTableName->getName(); } public function getUnqualifiedForeignTableName() { $parts = explode(".", $this->_foreignTableName->getName()); return strtolower(end($parts)); } public function getQuotedForeignTableName(AbstractPlatform $platform) { return $this->_foreignTableName->getQuotedName($platform); } public function getForeignColumns() { return array_keys($this->_foreignColumnNames); } public function getQuotedForeignColumns(AbstractPlatform $platform) { $columns = array(); foreach ($this->_foreignColumnNames as $column) { $columns[] = $column->getQuotedName($platform); } return $columns; } public function hasOption($name) { return isset($this->_options[$name]); } public function getOption($name) { return $this->_options[$name]; } public function getOptions() { return $this->_options; } public function onUpdate() { return $this->onEvent('onUpdate'); } public function onDelete() { return $this->onEvent('onDelete'); } private function onEvent($event) { if (isset($this->_options[$event])) { $onEvent = strtoupper($this->_options[$event]); if ( ! in_array($onEvent, array('NO ACTION', 'RESTRICT'))) { return $onEvent; } } return false; } public function intersectsIndexColumns(Index $index) { foreach ($index->getColumns() as $indexColumn) { foreach ($this->_localColumnNames as $localColumn) { if (strtolower($indexColumn) === strtolower($localColumn->getName())) { return true; } } } return false; } } 
<?php
 namespace Doctrine\DBAL\Schema; use Doctrine\DBAL\Schema\Visitor\CreateSchemaSqlCollector; use Doctrine\DBAL\Schema\Visitor\DropSchemaSqlCollector; use Doctrine\DBAL\Schema\Visitor\NamespaceVisitor; use Doctrine\DBAL\Schema\Visitor\Visitor; use Doctrine\DBAL\Platforms\AbstractPlatform; class Schema extends AbstractAsset { private $namespaces = array(); protected $_tables = array(); protected $_sequences = array(); protected $_schemaConfig = false; public function __construct( array $tables = array(), array $sequences = array(), SchemaConfig $schemaConfig = null, array $namespaces = array() ) { if ($schemaConfig == null) { $schemaConfig = new SchemaConfig(); } $this->_schemaConfig = $schemaConfig; $this->_setName($schemaConfig->getName() ?: 'public'); foreach ($namespaces as $namespace) { $this->createNamespace($namespace); } foreach ($tables as $table) { $this->_addTable($table); } foreach ($sequences as $sequence) { $this->_addSequence($sequence); } } public function hasExplicitForeignKeyIndexes() { return $this->_schemaConfig->hasExplicitForeignKeyIndexes(); } protected function _addTable(Table $table) { $namespaceName = $table->getNamespaceName(); $tableName = $table->getFullQualifiedName($this->getName()); if (isset($this->_tables[$tableName])) { throw SchemaException::tableAlreadyExists($tableName); } if ( ! $table->isInDefaultNamespace($this->getName()) && ! $this->hasNamespace($namespaceName)) { $this->createNamespace($namespaceName); } $this->_tables[$tableName] = $table; $table->setSchemaConfig($this->_schemaConfig); } protected function _addSequence(Sequence $sequence) { $namespaceName = $sequence->getNamespaceName(); $seqName = $sequence->getFullQualifiedName($this->getName()); if (isset($this->_sequences[$seqName])) { throw SchemaException::sequenceAlreadyExists($seqName); } if ( ! $sequence->isInDefaultNamespace($this->getName()) && ! $this->hasNamespace($namespaceName)) { $this->createNamespace($namespaceName); } $this->_sequences[$seqName] = $sequence; } public function getNamespaces() { return $this->namespaces; } public function getTables() { return $this->_tables; } public function getTable($tableName) { $tableName = $this->getFullQualifiedAssetName($tableName); if (!isset($this->_tables[$tableName])) { throw SchemaException::tableDoesNotExist($tableName); } return $this->_tables[$tableName]; } private function getFullQualifiedAssetName($name) { $name = $this->getUnquotedAssetName($name); if (strpos($name, ".") === false) { $name = $this->getName() . "." . $name; } return strtolower($name); } private function getUnquotedAssetName($assetName) { if ($this->isIdentifierQuoted($assetName)) { return $this->trimQuotes($assetName); } return $assetName; } public function hasNamespace($namespaceName) { $namespaceName = strtolower($this->getUnquotedAssetName($namespaceName)); return isset($this->namespaces[$namespaceName]); } public function hasTable($tableName) { $tableName = $this->getFullQualifiedAssetName($tableName); return isset($this->_tables[$tableName]); } public function getTableNames() { return array_keys($this->_tables); } public function hasSequence($sequenceName) { $sequenceName = $this->getFullQualifiedAssetName($sequenceName); return isset($this->_sequences[$sequenceName]); } public function getSequence($sequenceName) { $sequenceName = $this->getFullQualifiedAssetName($sequenceName); if (!$this->hasSequence($sequenceName)) { throw SchemaException::sequenceDoesNotExist($sequenceName); } return $this->_sequences[$sequenceName]; } public function getSequences() { return $this->_sequences; } public function createNamespace($namespaceName) { $unquotedNamespaceName = strtolower($this->getUnquotedAssetName($namespaceName)); if (isset($this->namespaces[$unquotedNamespaceName])) { throw SchemaException::namespaceAlreadyExists($unquotedNamespaceName); } $this->namespaces[$unquotedNamespaceName] = $namespaceName; return $this; } public function createTable($tableName) { $table = new Table($tableName); $this->_addTable($table); foreach ($this->_schemaConfig->getDefaultTableOptions() as $name => $value) { $table->addOption($name, $value); } return $table; } public function renameTable($oldTableName, $newTableName) { $table = $this->getTable($oldTableName); $table->_setName($newTableName); $this->dropTable($oldTableName); $this->_addTable($table); return $this; } public function dropTable($tableName) { $tableName = $this->getFullQualifiedAssetName($tableName); $this->getTable($tableName); unset($this->_tables[$tableName]); return $this; } public function createSequence($sequenceName, $allocationSize=1, $initialValue=1) { $seq = new Sequence($sequenceName, $allocationSize, $initialValue); $this->_addSequence($seq); return $seq; } public function dropSequence($sequenceName) { $sequenceName = $this->getFullQualifiedAssetName($sequenceName); unset($this->_sequences[$sequenceName]); return $this; } public function toSql(AbstractPlatform $platform) { $sqlCollector = new CreateSchemaSqlCollector($platform); $this->visit($sqlCollector); return $sqlCollector->getQueries(); } public function toDropSql(AbstractPlatform $platform) { $dropSqlCollector = new DropSchemaSqlCollector($platform); $this->visit($dropSqlCollector); return $dropSqlCollector->getQueries(); } public function getMigrateToSql(Schema $toSchema, AbstractPlatform $platform) { $comparator = new Comparator(); $schemaDiff = $comparator->compare($this, $toSchema); return $schemaDiff->toSql($platform); } public function getMigrateFromSql(Schema $fromSchema, AbstractPlatform $platform) { $comparator = new Comparator(); $schemaDiff = $comparator->compare($fromSchema, $this); return $schemaDiff->toSql($platform); } public function visit(Visitor $visitor) { $visitor->acceptSchema($this); if ($visitor instanceof NamespaceVisitor) { foreach ($this->namespaces as $namespace) { $visitor->acceptNamespace($namespace); } } foreach ($this->_tables as $table) { $table->visit($visitor); } foreach ($this->_sequences as $sequence) { $sequence->visit($visitor); } } public function __clone() { foreach ($this->_tables as $k => $table) { $this->_tables[$k] = clone $table; } foreach ($this->_sequences as $k => $sequence) { $this->_sequences[$k] = clone $sequence; } } } 
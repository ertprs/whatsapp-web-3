<?php
 namespace Doctrine\DBAL\Schema; use Doctrine\DBAL\Types\Type; use Doctrine\DBAL\Schema\Visitor\Visitor; use Doctrine\DBAL\DBALException; class Table extends AbstractAsset { protected $_name = null; protected $_columns = array(); private $implicitIndexes = array(); protected $_indexes = array(); protected $_primaryKeyName = false; protected $_fkConstraints = array(); protected $_options = array(); protected $_schemaConfig = null; public function __construct($tableName, array $columns=array(), array $indexes=array(), array $fkConstraints=array(), $idGeneratorType = 0, array $options=array()) { if (strlen($tableName) == 0) { throw DBALException::invalidTableName($tableName); } $this->_setName($tableName); foreach ($columns as $column) { $this->_addColumn($column); } foreach ($indexes as $idx) { $this->_addIndex($idx); } foreach ($fkConstraints as $constraint) { $this->_addForeignKeyConstraint($constraint); } $this->_options = $options; } public function setSchemaConfig(SchemaConfig $schemaConfig) { $this->_schemaConfig = $schemaConfig; } protected function _getMaxIdentifierLength() { if ($this->_schemaConfig instanceof SchemaConfig) { return $this->_schemaConfig->getMaxIdentifierLength(); } else { return 63; } } public function setPrimaryKey(array $columns, $indexName = false) { $this->_addIndex($this->_createIndex($columns, $indexName ?: "primary", true, true)); foreach ($columns as $columnName) { $column = $this->getColumn($columnName); $column->setNotnull(true); } return $this; } public function addIndex(array $columnNames, $indexName = null, array $flags = array(), array $options = array()) { if ($indexName == null) { $indexName = $this->_generateIdentifierName( array_merge(array($this->getName()), $columnNames), "idx", $this->_getMaxIdentifierLength() ); } return $this->_addIndex($this->_createIndex($columnNames, $indexName, false, false, $flags, $options)); } public function dropPrimaryKey() { $this->dropIndex($this->_primaryKeyName); $this->_primaryKeyName = false; } public function dropIndex($indexName) { $indexName = $this->normalizeIdentifier($indexName); if ( ! $this->hasIndex($indexName)) { throw SchemaException::indexDoesNotExist($indexName, $this->_name); } unset($this->_indexes[$indexName]); } public function addUniqueIndex(array $columnNames, $indexName = null, array $options = array()) { if ($indexName === null) { $indexName = $this->_generateIdentifierName( array_merge(array($this->getName()), $columnNames), "uniq", $this->_getMaxIdentifierLength() ); } return $this->_addIndex($this->_createIndex($columnNames, $indexName, true, false, array(), $options)); } public function renameIndex($oldIndexName, $newIndexName = null) { $oldIndexName = $this->normalizeIdentifier($oldIndexName); $normalizedNewIndexName = $this->normalizeIdentifier($newIndexName); if ($oldIndexName === $normalizedNewIndexName) { return $this; } if ( ! $this->hasIndex($oldIndexName)) { throw SchemaException::indexDoesNotExist($oldIndexName, $this->_name); } if ($this->hasIndex($normalizedNewIndexName)) { throw SchemaException::indexAlreadyExists($normalizedNewIndexName, $this->_name); } $oldIndex = $this->_indexes[$oldIndexName]; if ($oldIndex->isPrimary()) { $this->dropPrimaryKey(); return $this->setPrimaryKey($oldIndex->getColumns(), $newIndexName); } unset($this->_indexes[$oldIndexName]); if ($oldIndex->isUnique()) { return $this->addUniqueIndex($oldIndex->getColumns(), $newIndexName, $oldIndex->getOptions()); } return $this->addIndex($oldIndex->getColumns(), $newIndexName, $oldIndex->getFlags(), $oldIndex->getOptions()); } public function columnsAreIndexed(array $columnsNames) { foreach ($this->getIndexes() as $index) { if ($index->spansColumns($columnsNames)) { return true; } } return false; } private function _createIndex(array $columnNames, $indexName, $isUnique, $isPrimary, array $flags = array(), array $options = array()) { if (preg_match('(([^a-zA-Z0-9_]+))', $this->normalizeIdentifier($indexName))) { throw SchemaException::indexNameInvalid($indexName); } foreach ($columnNames as $columnName => $indexColOptions) { if (is_numeric($columnName) && is_string($indexColOptions)) { $columnName = $indexColOptions; } if ( ! $this->hasColumn($columnName)) { throw SchemaException::columnDoesNotExist($columnName, $this->_name); } } return new Index($indexName, $columnNames, $isUnique, $isPrimary, $flags, $options); } public function addColumn($columnName, $typeName, array $options=array()) { $column = new Column($columnName, Type::getType($typeName), $options); $this->_addColumn($column); return $column; } public function renameColumn($oldColumnName, $newColumnName) { throw new DBALException("Table#renameColumn() was removed, because it drops and recreates " . "the column instead. There is no fix available, because a schema diff cannot reliably detect if a " . "column was renamed or one column was created and another one dropped."); } public function changeColumn($columnName, array $options) { $column = $this->getColumn($columnName); $column->setOptions($options); return $this; } public function dropColumn($columnName) { $columnName = $this->normalizeIdentifier($columnName); unset($this->_columns[$columnName]); return $this; } public function addForeignKeyConstraint($foreignTable, array $localColumnNames, array $foreignColumnNames, array $options=array(), $constraintName = null) { $constraintName = $constraintName ?: $this->_generateIdentifierName(array_merge((array) $this->getName(), $localColumnNames), "fk", $this->_getMaxIdentifierLength()); return $this->addNamedForeignKeyConstraint($constraintName, $foreignTable, $localColumnNames, $foreignColumnNames, $options); } public function addUnnamedForeignKeyConstraint($foreignTable, array $localColumnNames, array $foreignColumnNames, array $options=array()) { return $this->addForeignKeyConstraint($foreignTable, $localColumnNames, $foreignColumnNames, $options); } public function addNamedForeignKeyConstraint($name, $foreignTable, array $localColumnNames, array $foreignColumnNames, array $options=array()) { if ($foreignTable instanceof Table) { foreach ($foreignColumnNames as $columnName) { if ( ! $foreignTable->hasColumn($columnName)) { throw SchemaException::columnDoesNotExist($columnName, $foreignTable->getName()); } } } foreach ($localColumnNames as $columnName) { if ( ! $this->hasColumn($columnName)) { throw SchemaException::columnDoesNotExist($columnName, $this->_name); } } $constraint = new ForeignKeyConstraint( $localColumnNames, $foreignTable, $foreignColumnNames, $name, $options ); $this->_addForeignKeyConstraint($constraint); return $this; } public function addOption($name, $value) { $this->_options[$name] = $value; return $this; } protected function _addColumn(Column $column) { $columnName = $column->getName(); $columnName = $this->normalizeIdentifier($columnName); if (isset($this->_columns[$columnName])) { throw SchemaException::columnAlreadyExists($this->getName(), $columnName); } $this->_columns[$columnName] = $column; } protected function _addIndex(Index $indexCandidate) { $indexName = $indexCandidate->getName(); $indexName = $this->normalizeIdentifier($indexName); $replacedImplicitIndexes = array(); foreach ($this->implicitIndexes as $name => $implicitIndex) { if ($implicitIndex->isFullfilledBy($indexCandidate) && isset($this->_indexes[$name])) { $replacedImplicitIndexes[] = $name; } } if ((isset($this->_indexes[$indexName]) && ! in_array($indexName, $replacedImplicitIndexes, true)) || ($this->_primaryKeyName != false && $indexCandidate->isPrimary()) ) { throw SchemaException::indexAlreadyExists($indexName, $this->_name); } foreach ($replacedImplicitIndexes as $name) { unset($this->_indexes[$name], $this->implicitIndexes[$name]); } if ($indexCandidate->isPrimary()) { $this->_primaryKeyName = $indexName; } $this->_indexes[$indexName] = $indexCandidate; return $this; } protected function _addForeignKeyConstraint(ForeignKeyConstraint $constraint) { $constraint->setLocalTable($this); if (strlen($constraint->getName())) { $name = $constraint->getName(); } else { $name = $this->_generateIdentifierName( array_merge((array) $this->getName(), $constraint->getLocalColumns()), "fk", $this->_getMaxIdentifierLength() ); } $name = $this->normalizeIdentifier($name); $this->_fkConstraints[$name] = $constraint; $indexName = $this->_generateIdentifierName( array_merge(array($this->getName()), $constraint->getColumns()), "idx", $this->_getMaxIdentifierLength() ); $indexCandidate = $this->_createIndex($constraint->getColumns(), $indexName, false, false); foreach ($this->_indexes as $existingIndex) { if ($indexCandidate->isFullfilledBy($existingIndex)) { return; } } $this->_addIndex($indexCandidate); $this->implicitIndexes[$this->normalizeIdentifier($indexName)] = $indexCandidate; } public function hasForeignKey($constraintName) { $constraintName = $this->normalizeIdentifier($constraintName); return isset($this->_fkConstraints[$constraintName]); } public function getForeignKey($constraintName) { $constraintName = $this->normalizeIdentifier($constraintName); if (!$this->hasForeignKey($constraintName)) { throw SchemaException::foreignKeyDoesNotExist($constraintName, $this->_name); } return $this->_fkConstraints[$constraintName]; } public function removeForeignKey($constraintName) { $constraintName = $this->normalizeIdentifier($constraintName); if (!$this->hasForeignKey($constraintName)) { throw SchemaException::foreignKeyDoesNotExist($constraintName, $this->_name); } unset($this->_fkConstraints[$constraintName]); } public function getColumns() { $columns = $this->_columns; $pkCols = array(); $fkCols = array(); if ($this->hasPrimaryKey()) { $pkCols = $this->getPrimaryKey()->getColumns(); } foreach ($this->getForeignKeys() as $fk) { $fkCols = array_merge($fkCols, $fk->getColumns()); } $colNames = array_unique(array_merge($pkCols, $fkCols, array_keys($columns))); uksort($columns, function ($a, $b) use ($colNames) { return (array_search($a, $colNames) >= array_search($b, $colNames)); }); return $columns; } public function hasColumn($columnName) { $columnName = $this->normalizeIdentifier($columnName); return isset($this->_columns[$columnName]); } public function getColumn($columnName) { $columnName = $this->normalizeIdentifier($columnName); if ( ! $this->hasColumn($columnName)) { throw SchemaException::columnDoesNotExist($columnName, $this->_name); } return $this->_columns[$columnName]; } public function getPrimaryKey() { if ( ! $this->hasPrimaryKey()) { return null; } return $this->getIndex($this->_primaryKeyName); } public function getPrimaryKeyColumns() { if ( ! $this->hasPrimaryKey()) { throw new DBALException("Table " . $this->getName() . " has no primary key."); } return $this->getPrimaryKey()->getColumns(); } public function hasPrimaryKey() { return ($this->_primaryKeyName && $this->hasIndex($this->_primaryKeyName)); } public function hasIndex($indexName) { $indexName = $this->normalizeIdentifier($indexName); return (isset($this->_indexes[$indexName])); } public function getIndex($indexName) { $indexName = $this->normalizeIdentifier($indexName); if ( ! $this->hasIndex($indexName)) { throw SchemaException::indexDoesNotExist($indexName, $this->_name); } return $this->_indexes[$indexName]; } public function getIndexes() { return $this->_indexes; } public function getForeignKeys() { return $this->_fkConstraints; } public function hasOption($name) { return isset($this->_options[$name]); } public function getOption($name) { return $this->_options[$name]; } public function getOptions() { return $this->_options; } public function visit(Visitor $visitor) { $visitor->acceptTable($this); foreach ($this->getColumns() as $column) { $visitor->acceptColumn($this, $column); } foreach ($this->getIndexes() as $index) { $visitor->acceptIndex($this, $index); } foreach ($this->getForeignKeys() as $constraint) { $visitor->acceptForeignKey($this, $constraint); } } public function __clone() { foreach ($this->_columns as $k => $column) { $this->_columns[$k] = clone $column; } foreach ($this->_indexes as $k => $index) { $this->_indexes[$k] = clone $index; } foreach ($this->_fkConstraints as $k => $fk) { $this->_fkConstraints[$k] = clone $fk; $this->_fkConstraints[$k]->setLocalTable($this); } } private function normalizeIdentifier($identifier) { return $this->trimQuotes(strtolower($identifier)); } } 
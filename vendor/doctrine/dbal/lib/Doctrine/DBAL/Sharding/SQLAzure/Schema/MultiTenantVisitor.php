<?php
 namespace Doctrine\DBAL\Sharding\SQLAzure\Schema; use Doctrine\DBAL\Schema\Visitor\Visitor; use Doctrine\DBAL\Schema\Table; use Doctrine\DBAL\Schema\Schema; use Doctrine\DBAL\Schema\Column; use Doctrine\DBAL\Schema\ForeignKeyConstraint; use Doctrine\DBAL\Schema\Sequence; use Doctrine\DBAL\Schema\Index; class MultiTenantVisitor implements Visitor { private $excludedTables = array(); private $tenantColumnName; private $tenantColumnType = 'integer'; private $distributionName; public function __construct(array $excludedTables = array(), $tenantColumnName = 'tenant_id', $distributionName = null) { $this->excludedTables = $excludedTables; $this->tenantColumnName = $tenantColumnName; $this->distributionName = $distributionName ?: $tenantColumnName; } public function acceptTable(Table $table) { if (in_array($table->getName(), $this->excludedTables)) { return; } $table->addColumn($this->tenantColumnName, $this->tenantColumnType, array( 'default' => "federation_filtering_value('". $this->distributionName ."')", )); $clusteredIndex = $this->getClusteredIndex($table); $indexColumns = $clusteredIndex->getColumns(); $indexColumns[] = $this->tenantColumnName; if ($clusteredIndex->isPrimary()) { $table->dropPrimaryKey(); $table->setPrimaryKey($indexColumns); } else { $table->dropIndex($clusteredIndex->getName()); $table->addIndex($indexColumns, $clusteredIndex->getName()); $table->getIndex($clusteredIndex->getName())->addFlag('clustered'); } } private function getClusteredIndex($table) { foreach ($table->getIndexes() as $index) { if ($index->isPrimary() && ! $index->hasFlag('nonclustered')) { return $index; } elseif ($index->hasFlag('clustered')) { return $index; } } throw new \RuntimeException("No clustered index found on table " . $table->getName()); } public function acceptSchema(Schema $schema) { } public function acceptColumn(Table $table, Column $column) { } public function acceptForeignKey(Table $localTable, ForeignKeyConstraint $fkConstraint) { } public function acceptIndex(Table $table, Index $index) { } public function acceptSequence(Sequence $sequence) { } } 
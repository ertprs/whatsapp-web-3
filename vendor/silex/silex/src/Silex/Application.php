<?php
 namespace Silex; use Pimple\Container; use Pimple\ServiceProviderInterface; use Symfony\Component\EventDispatcher\EventDispatcherInterface; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\TerminableInterface; use Symfony\Component\HttpKernel\Event\FilterResponseEvent; use Symfony\Component\HttpKernel\Event\GetResponseEvent; use Symfony\Component\HttpKernel\Event\PostResponseEvent; use Symfony\Component\HttpKernel\Exception\HttpException; use Symfony\Component\HttpKernel\KernelEvents; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\HttpFoundation\StreamedResponse; use Symfony\Component\HttpFoundation\JsonResponse; use Silex\Api\BootableProviderInterface; use Silex\Api\EventListenerProviderInterface; use Silex\Api\ControllerProviderInterface; use Silex\Provider\ExceptionHandlerServiceProvider; use Silex\Provider\RoutingServiceProvider; use Silex\Provider\HttpKernelServiceProvider; class Application extends Container implements HttpKernelInterface, TerminableInterface { const VERSION = '2.2.0-DEV'; const EARLY_EVENT = 512; const LATE_EVENT = -512; protected $providers = array(); protected $booted = false; public function __construct(array $values = array()) { parent::__construct(); $this['request.http_port'] = 80; $this['request.https_port'] = 443; $this['debug'] = false; $this['charset'] = 'UTF-8'; $this['logger'] = null; $this->register(new HttpKernelServiceProvider()); $this->register(new RoutingServiceProvider()); $this->register(new ExceptionHandlerServiceProvider()); foreach ($values as $key => $value) { $this[$key] = $value; } } public function register(ServiceProviderInterface $provider, array $values = array()) { $this->providers[] = $provider; parent::register($provider, $values); return $this; } public function boot() { if ($this->booted) { return; } $this->booted = true; foreach ($this->providers as $provider) { if ($provider instanceof EventListenerProviderInterface) { $provider->subscribe($this, $this['dispatcher']); } if ($provider instanceof BootableProviderInterface) { $provider->boot($this); } } } public function match($pattern, $to = null) { return $this['controllers']->match($pattern, $to); } public function get($pattern, $to = null) { return $this['controllers']->get($pattern, $to); } public function post($pattern, $to = null) { return $this['controllers']->post($pattern, $to); } public function put($pattern, $to = null) { return $this['controllers']->put($pattern, $to); } public function delete($pattern, $to = null) { return $this['controllers']->delete($pattern, $to); } public function options($pattern, $to = null) { return $this['controllers']->options($pattern, $to); } public function patch($pattern, $to = null) { return $this['controllers']->patch($pattern, $to); } public function on($eventName, $callback, $priority = 0) { if ($this->booted) { $this['dispatcher']->addListener($eventName, $this['callback_resolver']->resolveCallback($callback), $priority); return; } $this->extend('dispatcher', function (EventDispatcherInterface $dispatcher, $app) use ($callback, $priority, $eventName) { $dispatcher->addListener($eventName, $app['callback_resolver']->resolveCallback($callback), $priority); return $dispatcher; }); } public function before($callback, $priority = 0) { $app = $this; $this->on(KernelEvents::REQUEST, function (GetResponseEvent $event) use ($callback, $app) { if (!$event->isMasterRequest()) { return; } $ret = call_user_func($app['callback_resolver']->resolveCallback($callback), $event->getRequest(), $app); if ($ret instanceof Response) { $event->setResponse($ret); } }, $priority); } public function after($callback, $priority = 0) { $app = $this; $this->on(KernelEvents::RESPONSE, function (FilterResponseEvent $event) use ($callback, $app) { if (!$event->isMasterRequest()) { return; } $response = call_user_func($app['callback_resolver']->resolveCallback($callback), $event->getRequest(), $event->getResponse(), $app); if ($response instanceof Response) { $event->setResponse($response); } elseif (null !== $response) { throw new \RuntimeException('An after middleware returned an invalid response value. Must return null or an instance of Response.'); } }, $priority); } public function finish($callback, $priority = 0) { $app = $this; $this->on(KernelEvents::TERMINATE, function (PostResponseEvent $event) use ($callback, $app) { call_user_func($app['callback_resolver']->resolveCallback($callback), $event->getRequest(), $event->getResponse(), $app); }, $priority); } public function abort($statusCode, $message = '', array $headers = array()) { throw new HttpException($statusCode, $message, null, $headers); } public function error($callback, $priority = -8) { $this->on(KernelEvents::EXCEPTION, new ExceptionListenerWrapper($this, $callback), $priority); } public function view($callback, $priority = 0) { $this->on(KernelEvents::VIEW, new ViewListenerWrapper($this, $callback), $priority); } public function flush() { $this['routes']->addCollection($this['controllers']->flush()); } public function redirect($url, $status = 302) { return new RedirectResponse($url, $status); } public function stream($callback = null, $status = 200, array $headers = array()) { return new StreamedResponse($callback, $status, $headers); } public function escape($text, $flags = ENT_COMPAT, $charset = null, $doubleEncode = true) { return htmlspecialchars($text, $flags, $charset ?: $this['charset'], $doubleEncode); } public function json($data = array(), $status = 200, array $headers = array()) { return new JsonResponse($data, $status, $headers); } public function sendFile($file, $status = 200, array $headers = array(), $contentDisposition = null) { return new BinaryFileResponse($file, $status, $headers, true, $contentDisposition); } public function mount($prefix, $controllers) { if ($controllers instanceof ControllerProviderInterface) { $connectedControllers = $controllers->connect($this); if (!$connectedControllers instanceof ControllerCollection) { throw new \LogicException(sprintf('The method "%s::connect" must return a "ControllerCollection" instance. Got: "%s"', get_class($controllers), is_object($connectedControllers) ? get_class($connectedControllers) : gettype($connectedControllers))); } $controllers = $connectedControllers; } elseif (!$controllers instanceof ControllerCollection && !is_callable($controllers)) { throw new \LogicException('The "mount" method takes either a "ControllerCollection" instance, "ControllerProviderInterface" instance, or a callable.'); } $this['controllers']->mount($prefix, $controllers); return $this; } public function run(Request $request = null) { if (null === $request) { $request = Request::createFromGlobals(); } $response = $this->handle($request); $response->send(); $this->terminate($request, $response); } public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { if (!$this->booted) { $this->boot(); } $this->flush(); return $this['kernel']->handle($request, $type, $catch); } public function terminate(Request $request, Response $response) { $this['kernel']->terminate($request, $response); } } 
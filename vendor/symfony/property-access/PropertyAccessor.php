<?php
 namespace Symfony\Component\PropertyAccess; use Psr\Cache\CacheItemPoolInterface; use Psr\Log\LoggerInterface; use Symfony\Component\Cache\Adapter\AdapterInterface; use Symfony\Component\Cache\Adapter\ApcuAdapter; use Symfony\Component\Cache\Adapter\NullAdapter; use Symfony\Component\Inflector\Inflector; use Symfony\Component\PropertyAccess\Exception\AccessException; use Symfony\Component\PropertyAccess\Exception\InvalidArgumentException; use Symfony\Component\PropertyAccess\Exception\NoSuchPropertyException; use Symfony\Component\PropertyAccess\Exception\NoSuchIndexException; use Symfony\Component\PropertyAccess\Exception\UnexpectedTypeException; class PropertyAccessor implements PropertyAccessorInterface { const VALUE = 0; const REF = 1; const IS_REF_CHAINED = 2; const ACCESS_HAS_PROPERTY = 0; const ACCESS_TYPE = 1; const ACCESS_NAME = 2; const ACCESS_REF = 3; const ACCESS_ADDER = 4; const ACCESS_REMOVER = 5; const ACCESS_TYPE_METHOD = 0; const ACCESS_TYPE_PROPERTY = 1; const ACCESS_TYPE_MAGIC = 2; const ACCESS_TYPE_ADDER_AND_REMOVER = 3; const ACCESS_TYPE_NOT_FOUND = 4; const CACHE_PREFIX_READ = 'r'; const CACHE_PREFIX_WRITE = 'w'; const CACHE_PREFIX_PROPERTY_PATH = 'p'; private $magicCall; private $ignoreInvalidIndices; private $cacheItemPool; private $readPropertyCache = array(); private $writePropertyCache = array(); private static $previousErrorHandler = false; private static $errorHandler = array(__CLASS__, 'handleError'); private static $resultProto = array(self::VALUE => null); private $propertyPathCache = array(); public function __construct($magicCall = false, $throwExceptionOnInvalidIndex = false, CacheItemPoolInterface $cacheItemPool = null) { $this->magicCall = $magicCall; $this->ignoreInvalidIndices = !$throwExceptionOnInvalidIndex; $this->cacheItemPool = $cacheItemPool instanceof NullAdapter ? null : $cacheItemPool; } public function getValue($objectOrArray, $propertyPath) { $propertyPath = $this->getPropertyPath($propertyPath); $zval = array( self::VALUE => $objectOrArray, ); $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength(), $this->ignoreInvalidIndices); return $propertyValues[count($propertyValues) - 1][self::VALUE]; } public function setValue(&$objectOrArray, $propertyPath, $value) { $propertyPath = $this->getPropertyPath($propertyPath); $zval = array( self::VALUE => $objectOrArray, self::REF => &$objectOrArray, ); $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength() - 1); $overwrite = true; try { if (\PHP_VERSION_ID < 70000 && false === self::$previousErrorHandler) { self::$previousErrorHandler = set_error_handler(self::$errorHandler); } for ($i = count($propertyValues) - 1; 0 <= $i; --$i) { $zval = $propertyValues[$i]; unset($propertyValues[$i]); if ($overwrite) { $property = $propertyPath->getElement($i); if ($propertyPath->isIndex($i)) { if ($overwrite = !isset($zval[self::REF])) { $ref = &$zval[self::REF]; $ref = $zval[self::VALUE]; } $this->writeIndex($zval, $property, $value); if ($overwrite) { $zval[self::VALUE] = $zval[self::REF]; } } else { $this->writeProperty($zval, $property, $value); } if (is_object($zval[self::VALUE]) || isset($zval[self::IS_REF_CHAINED])) { break; } } $value = $zval[self::VALUE]; } } catch (\TypeError $e) { self::throwInvalidArgumentException($e->getMessage(), $e->getTrace(), 0); throw $e; } finally { if (\PHP_VERSION_ID < 70000 && false !== self::$previousErrorHandler) { restore_error_handler(); self::$previousErrorHandler = false; } } } public static function handleError($type, $message, $file, $line, $context) { if (E_RECOVERABLE_ERROR === $type) { self::throwInvalidArgumentException($message, debug_backtrace(false), 1); } return null !== self::$previousErrorHandler && false !== call_user_func(self::$previousErrorHandler, $type, $message, $file, $line, $context); } private static function throwInvalidArgumentException($message, $trace, $i) { if (isset($trace[$i]['file']) && __FILE__ === $trace[$i]['file'] && isset($trace[$i]['args'][0])) { $pos = strpos($message, $delim = 'must be of the type ') ?: (strpos($message, $delim = 'must be an instance of ') ?: strpos($message, $delim = 'must implement interface ')); $pos += strlen($delim); $type = $trace[$i]['args'][0]; $type = is_object($type) ? get_class($type) : gettype($type); throw new InvalidArgumentException(sprintf('Expected argument of type "%s", "%s" given', substr($message, $pos, strpos($message, ',', $pos) - $pos), $type)); } } public function isReadable($objectOrArray, $propertyPath) { if (!$propertyPath instanceof PropertyPathInterface) { $propertyPath = new PropertyPath($propertyPath); } try { $zval = array( self::VALUE => $objectOrArray, ); $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength(), $this->ignoreInvalidIndices); return true; } catch (AccessException $e) { return false; } catch (UnexpectedTypeException $e) { return false; } } public function isWritable($objectOrArray, $propertyPath) { $propertyPath = $this->getPropertyPath($propertyPath); try { $zval = array( self::VALUE => $objectOrArray, ); $propertyValues = $this->readPropertiesUntil($zval, $propertyPath, $propertyPath->getLength() - 1); for ($i = count($propertyValues) - 1; 0 <= $i; --$i) { $zval = $propertyValues[$i]; unset($propertyValues[$i]); if ($propertyPath->isIndex($i)) { if (!$zval[self::VALUE] instanceof \ArrayAccess && !is_array($zval[self::VALUE])) { return false; } } else { if (!$this->isPropertyWritable($zval[self::VALUE], $propertyPath->getElement($i))) { return false; } } if (is_object($zval[self::VALUE])) { return true; } } return true; } catch (AccessException $e) { return false; } catch (UnexpectedTypeException $e) { return false; } } private function readPropertiesUntil($zval, PropertyPathInterface $propertyPath, $lastIndex, $ignoreInvalidIndices = true) { if (!is_object($zval[self::VALUE]) && !is_array($zval[self::VALUE])) { throw new UnexpectedTypeException($zval[self::VALUE], $propertyPath, 0); } $propertyValues = array($zval); for ($i = 0; $i < $lastIndex; ++$i) { $property = $propertyPath->getElement($i); $isIndex = $propertyPath->isIndex($i); if ($isIndex) { if (($zval[self::VALUE] instanceof \ArrayAccess && !$zval[self::VALUE]->offsetExists($property)) || (is_array($zval[self::VALUE]) && !isset($zval[self::VALUE][$property]) && !array_key_exists($property, $zval[self::VALUE])) ) { if (!$ignoreInvalidIndices) { if (!is_array($zval[self::VALUE])) { if (!$zval[self::VALUE] instanceof \Traversable) { throw new NoSuchIndexException(sprintf( 'Cannot read index "%s" while trying to traverse path "%s".', $property, (string) $propertyPath )); } $zval[self::VALUE] = iterator_to_array($zval[self::VALUE]); } throw new NoSuchIndexException(sprintf( 'Cannot read index "%s" while trying to traverse path "%s". Available indices are "%s".', $property, (string) $propertyPath, print_r(array_keys($zval[self::VALUE]), true) )); } if ($i + 1 < $propertyPath->getLength()) { if (isset($zval[self::REF])) { $zval[self::VALUE][$property] = array(); $zval[self::REF] = $zval[self::VALUE]; } else { $zval[self::VALUE] = array($property => array()); } } } $zval = $this->readIndex($zval, $property); } else { $zval = $this->readProperty($zval, $property); } if ($i + 1 < $propertyPath->getLength() && !is_object($zval[self::VALUE]) && !is_array($zval[self::VALUE])) { throw new UnexpectedTypeException($zval[self::VALUE], $propertyPath, $i + 1); } if (isset($zval[self::REF]) && (0 === $i || isset($propertyValues[$i - 1][self::IS_REF_CHAINED]))) { $zval[self::IS_REF_CHAINED] = true; } $propertyValues[] = $zval; } return $propertyValues; } private function readIndex($zval, $index) { if (!$zval[self::VALUE] instanceof \ArrayAccess && !is_array($zval[self::VALUE])) { throw new NoSuchIndexException(sprintf('Cannot read index "%s" from object of type "%s" because it doesn\'t implement \ArrayAccess.', $index, get_class($zval[self::VALUE]))); } $result = self::$resultProto; if (isset($zval[self::VALUE][$index])) { $result[self::VALUE] = $zval[self::VALUE][$index]; if (!isset($zval[self::REF])) { } elseif (is_array($zval[self::VALUE])) { $result[self::REF] = &$zval[self::REF][$index]; } elseif (is_object($result[self::VALUE])) { $result[self::REF] = $result[self::VALUE]; } } return $result; } private function readProperty($zval, $property) { if (!is_object($zval[self::VALUE])) { throw new NoSuchPropertyException(sprintf('Cannot read property "%s" from an array. Maybe you intended to write the property path as "[%s]" instead.', $property, $property)); } $result = self::$resultProto; $object = $zval[self::VALUE]; $access = $this->getReadAccessInfo(get_class($object), $property); if (self::ACCESS_TYPE_METHOD === $access[self::ACCESS_TYPE]) { $result[self::VALUE] = $object->{$access[self::ACCESS_NAME]}(); } elseif (self::ACCESS_TYPE_PROPERTY === $access[self::ACCESS_TYPE]) { $result[self::VALUE] = $object->{$access[self::ACCESS_NAME]}; if ($access[self::ACCESS_REF] && isset($zval[self::REF])) { $result[self::REF] = &$object->{$access[self::ACCESS_NAME]}; } } elseif (!$access[self::ACCESS_HAS_PROPERTY] && property_exists($object, $property)) { $result[self::VALUE] = $object->$property; if (isset($zval[self::REF])) { $result[self::REF] = &$object->$property; } } elseif (self::ACCESS_TYPE_MAGIC === $access[self::ACCESS_TYPE]) { $result[self::VALUE] = $object->{$access[self::ACCESS_NAME]}(); } else { throw new NoSuchPropertyException($access[self::ACCESS_NAME]); } if (isset($zval[self::REF]) && is_object($result[self::VALUE])) { $result[self::REF] = $result[self::VALUE]; } return $result; } private function getReadAccessInfo($class, $property) { $key = (false !== strpos($class, '@') ? rawurlencode($class) : $class).'..'.$property; if (isset($this->readPropertyCache[$key])) { return $this->readPropertyCache[$key]; } if ($this->cacheItemPool) { $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_READ.str_replace('\\', '.', $key)); if ($item->isHit()) { return $this->readPropertyCache[$key] = $item->get(); } } $access = array(); $reflClass = new \ReflectionClass($class); $access[self::ACCESS_HAS_PROPERTY] = $reflClass->hasProperty($property); $camelProp = $this->camelize($property); $getter = 'get'.$camelProp; $getsetter = lcfirst($camelProp); $isser = 'is'.$camelProp; $hasser = 'has'.$camelProp; if ($reflClass->hasMethod($getter) && $reflClass->getMethod($getter)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $getter; } elseif ($reflClass->hasMethod($getsetter) && $reflClass->getMethod($getsetter)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $getsetter; } elseif ($reflClass->hasMethod($isser) && $reflClass->getMethod($isser)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $isser; } elseif ($reflClass->hasMethod($hasser) && $reflClass->getMethod($hasser)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $hasser; } elseif ($reflClass->hasMethod('__get') && $reflClass->getMethod('__get')->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_PROPERTY; $access[self::ACCESS_NAME] = $property; $access[self::ACCESS_REF] = false; } elseif ($access[self::ACCESS_HAS_PROPERTY] && $reflClass->getProperty($property)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_PROPERTY; $access[self::ACCESS_NAME] = $property; $access[self::ACCESS_REF] = true; } elseif ($this->magicCall && $reflClass->hasMethod('__call') && $reflClass->getMethod('__call')->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_MAGIC; $access[self::ACCESS_NAME] = $getter; } else { $methods = array($getter, $getsetter, $isser, $hasser, '__get'); if ($this->magicCall) { $methods[] = '__call'; } $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_NOT_FOUND; $access[self::ACCESS_NAME] = sprintf( 'Neither the property "%s" nor one of the methods "%s()" '. 'exist and have public access in class "%s".', $property, implode('()", "', $methods), $reflClass->name ); } if (isset($item)) { $this->cacheItemPool->save($item->set($access)); } return $this->readPropertyCache[$key] = $access; } private function writeIndex($zval, $index, $value) { if (!$zval[self::VALUE] instanceof \ArrayAccess && !is_array($zval[self::VALUE])) { throw new NoSuchIndexException(sprintf('Cannot modify index "%s" in object of type "%s" because it doesn\'t implement \ArrayAccess', $index, get_class($zval[self::VALUE]))); } $zval[self::REF][$index] = $value; } private function writeProperty($zval, $property, $value) { if (!is_object($zval[self::VALUE])) { throw new NoSuchPropertyException(sprintf('Cannot write property "%s" to an array. Maybe you should write the property path as "[%s]" instead?', $property, $property)); } $object = $zval[self::VALUE]; $access = $this->getWriteAccessInfo(get_class($object), $property, $value); if (self::ACCESS_TYPE_METHOD === $access[self::ACCESS_TYPE]) { $object->{$access[self::ACCESS_NAME]}($value); } elseif (self::ACCESS_TYPE_PROPERTY === $access[self::ACCESS_TYPE]) { $object->{$access[self::ACCESS_NAME]} = $value; } elseif (self::ACCESS_TYPE_ADDER_AND_REMOVER === $access[self::ACCESS_TYPE]) { $this->writeCollection($zval, $property, $value, $access[self::ACCESS_ADDER], $access[self::ACCESS_REMOVER]); } elseif (!$access[self::ACCESS_HAS_PROPERTY] && property_exists($object, $property)) { $object->$property = $value; } elseif (self::ACCESS_TYPE_MAGIC === $access[self::ACCESS_TYPE]) { $object->{$access[self::ACCESS_NAME]}($value); } elseif (self::ACCESS_TYPE_NOT_FOUND === $access[self::ACCESS_TYPE]) { throw new NoSuchPropertyException(sprintf('Could not determine access type for property "%s".', $property)); } else { throw new NoSuchPropertyException($access[self::ACCESS_NAME]); } } private function writeCollection($zval, $property, $collection, $addMethod, $removeMethod) { $previousValue = $this->readProperty($zval, $property); $previousValue = $previousValue[self::VALUE]; if ($previousValue instanceof \Traversable) { $previousValue = iterator_to_array($previousValue); } if ($previousValue && is_array($previousValue)) { if (is_object($collection)) { $collection = iterator_to_array($collection); } foreach ($previousValue as $key => $item) { if (!in_array($item, $collection, true)) { unset($previousValue[$key]); $zval[self::VALUE]->{$removeMethod}($item); } } } else { $previousValue = false; } foreach ($collection as $item) { if (!$previousValue || !in_array($item, $previousValue, true)) { $zval[self::VALUE]->{$addMethod}($item); } } } private function getWriteAccessInfo($class, $property, $value) { $key = (false !== strpos($class, '@') ? rawurlencode($class) : $class).'..'.$property; if (isset($this->writePropertyCache[$key])) { return $this->writePropertyCache[$key]; } if ($this->cacheItemPool) { $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_WRITE.str_replace('\\', '.', $key)); if ($item->isHit()) { return $this->writePropertyCache[$key] = $item->get(); } } $access = array(); $reflClass = new \ReflectionClass($class); $access[self::ACCESS_HAS_PROPERTY] = $reflClass->hasProperty($property); $camelized = $this->camelize($property); $singulars = (array) Inflector::singularize($camelized); if (is_array($value) || $value instanceof \Traversable) { $methods = $this->findAdderAndRemover($reflClass, $singulars); if (null !== $methods) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_ADDER_AND_REMOVER; $access[self::ACCESS_ADDER] = $methods[0]; $access[self::ACCESS_REMOVER] = $methods[1]; } } if (!isset($access[self::ACCESS_TYPE])) { $setter = 'set'.$camelized; $getsetter = lcfirst($camelized); if ($this->isMethodAccessible($reflClass, $setter, 1)) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $setter; } elseif ($this->isMethodAccessible($reflClass, $getsetter, 1)) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_METHOD; $access[self::ACCESS_NAME] = $getsetter; } elseif ($this->isMethodAccessible($reflClass, '__set', 2)) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_PROPERTY; $access[self::ACCESS_NAME] = $property; } elseif ($access[self::ACCESS_HAS_PROPERTY] && $reflClass->getProperty($property)->isPublic()) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_PROPERTY; $access[self::ACCESS_NAME] = $property; } elseif ($this->magicCall && $this->isMethodAccessible($reflClass, '__call', 2)) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_MAGIC; $access[self::ACCESS_NAME] = $setter; } elseif (null !== $methods = $this->findAdderAndRemover($reflClass, $singulars)) { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_NOT_FOUND; $access[self::ACCESS_NAME] = sprintf( 'The property "%s" in class "%s" can be defined with the methods "%s()" but '. 'the new value must be an array or an instance of \Traversable, '. '"%s" given.', $property, $reflClass->name, implode('()", "', $methods), is_object($value) ? get_class($value) : gettype($value) ); } else { $access[self::ACCESS_TYPE] = self::ACCESS_TYPE_NOT_FOUND; $access[self::ACCESS_NAME] = sprintf( 'Neither the property "%s" nor one of the methods %s"%s()", "%s()", '. '"__set()" or "__call()" exist and have public access in class "%s".', $property, implode('', array_map(function ($singular) { return '"add'.$singular.'()"/"remove'.$singular.'()", '; }, $singulars)), $setter, $getsetter, $reflClass->name ); } } if (isset($item)) { $this->cacheItemPool->save($item->set($access)); } return $this->writePropertyCache[$key] = $access; } private function isPropertyWritable($object, $property) { if (!is_object($object)) { return false; } $access = $this->getWriteAccessInfo(get_class($object), $property, array()); return self::ACCESS_TYPE_METHOD === $access[self::ACCESS_TYPE] || self::ACCESS_TYPE_PROPERTY === $access[self::ACCESS_TYPE] || self::ACCESS_TYPE_ADDER_AND_REMOVER === $access[self::ACCESS_TYPE] || (!$access[self::ACCESS_HAS_PROPERTY] && property_exists($object, $property)) || self::ACCESS_TYPE_MAGIC === $access[self::ACCESS_TYPE]; } private function camelize($string) { return str_replace(' ', '', ucwords(str_replace('_', ' ', $string))); } private function findAdderAndRemover(\ReflectionClass $reflClass, array $singulars) { foreach ($singulars as $singular) { $addMethod = 'add'.$singular; $removeMethod = 'remove'.$singular; $addMethodFound = $this->isMethodAccessible($reflClass, $addMethod, 1); $removeMethodFound = $this->isMethodAccessible($reflClass, $removeMethod, 1); if ($addMethodFound && $removeMethodFound) { return array($addMethod, $removeMethod); } } } private function isMethodAccessible(\ReflectionClass $class, $methodName, $parameters) { if ($class->hasMethod($methodName)) { $method = $class->getMethod($methodName); if ($method->isPublic() && $method->getNumberOfRequiredParameters() <= $parameters && $method->getNumberOfParameters() >= $parameters) { return true; } } return false; } private function getPropertyPath($propertyPath) { if ($propertyPath instanceof PropertyPathInterface) { return $propertyPath; } if (isset($this->propertyPathCache[$propertyPath])) { return $this->propertyPathCache[$propertyPath]; } if ($this->cacheItemPool) { $item = $this->cacheItemPool->getItem(self::CACHE_PREFIX_PROPERTY_PATH.$propertyPath); if ($item->isHit()) { return $this->propertyPathCache[$propertyPath] = $item->get(); } } $propertyPathInstance = new PropertyPath($propertyPath); if (isset($item)) { $item->set($propertyPathInstance); $this->cacheItemPool->save($item); } return $this->propertyPathCache[$propertyPath] = $propertyPathInstance; } public static function createCache($namespace, $defaultLifetime, $version, LoggerInterface $logger = null) { if (!class_exists('Symfony\Component\Cache\Adapter\ApcuAdapter')) { throw new \RuntimeException(sprintf('The Symfony Cache component must be installed to use %s().', __METHOD__)); } if (!ApcuAdapter::isSupported()) { return new NullAdapter(); } $apcu = new ApcuAdapter($namespace, $defaultLifetime / 5, $version); if (null !== $logger) { $apcu->setLogger($logger); } return $apcu; } } 
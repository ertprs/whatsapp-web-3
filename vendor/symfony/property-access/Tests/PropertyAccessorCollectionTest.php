<?php
 namespace Symfony\Component\PropertyAccess\Tests; class PropertyAccessorCollectionTest_Car { private $axes; public function __construct($axes = null) { $this->axes = $axes; } public function addAxis($axis) { $this->axes[] = $axis; } public function removeAxis($axis) { foreach ($this->axes as $key => $value) { if ($value === $axis) { unset($this->axes[$key]); return; } } } public function getAxes() { return $this->axes; } } class PropertyAccessorCollectionTest_CarOnlyAdder { public function addAxis($axis) { } public function getAxes() { } } class PropertyAccessorCollectionTest_CarOnlyRemover { public function removeAxis($axis) { } public function getAxes() { } } class PropertyAccessorCollectionTest_CarNoAdderAndRemover { public function getAxes() { } } class PropertyAccessorCollectionTest_CompositeCar { public function getStructure() { } public function setStructure($structure) { } } class PropertyAccessorCollectionTest_CarStructure { public function addAxis($axis) { } public function removeAxis($axis) { } public function getAxes() { } } abstract class PropertyAccessorCollectionTest extends PropertyAccessorArrayAccessTest { public function testSetValueCallsAdderAndRemoverForCollections() { $axesBefore = $this->getContainer(array(1 => 'second', 3 => 'fourth', 4 => 'fifth')); $axesMerged = $this->getContainer(array(1 => 'first', 2 => 'second', 3 => 'third')); $axesAfter = $this->getContainer(array(1 => 'second', 5 => 'first', 6 => 'third')); $axesMergedCopy = is_object($axesMerged) ? clone $axesMerged : $axesMerged; $car = new PropertyAccessorCollectionTest_Car($axesBefore); $this->propertyAccessor->setValue($car, 'axes', $axesMerged); $this->assertEquals($axesAfter, $car->getAxes()); $this->assertEquals($axesMergedCopy, $axesMerged); } public function testSetValueCallsAdderAndRemoverForNestedCollections() { $car = $this->getMockBuilder(__CLASS__.'_CompositeCar')->getMock(); $structure = $this->getMockBuilder(__CLASS__.'_CarStructure')->getMock(); $axesBefore = $this->getContainer(array(1 => 'second', 3 => 'fourth')); $axesAfter = $this->getContainer(array(0 => 'first', 1 => 'second', 2 => 'third')); $car->expects($this->any()) ->method('getStructure') ->will($this->returnValue($structure)); $structure->expects($this->at(0)) ->method('getAxes') ->will($this->returnValue($axesBefore)); $structure->expects($this->at(1)) ->method('removeAxis') ->with('fourth'); $structure->expects($this->at(2)) ->method('addAxis') ->with('first'); $structure->expects($this->at(3)) ->method('addAxis') ->with('third'); $this->propertyAccessor->setValue($car, 'structure.axes', $axesAfter); } public function testSetValueFailsIfNoAdderNorRemoverFound() { $car = $this->getMockBuilder(__CLASS__.'_CarNoAdderAndRemover')->getMock(); $axesBefore = $this->getContainer(array(1 => 'second', 3 => 'fourth')); $axesAfter = $this->getContainer(array(0 => 'first', 1 => 'second', 2 => 'third')); $car->expects($this->any()) ->method('getAxes') ->will($this->returnValue($axesBefore)); $this->propertyAccessor->setValue($car, 'axes', $axesAfter); } public function testIsWritableReturnsTrueIfAdderAndRemoverExists() { $car = $this->getMockBuilder(__CLASS__.'_Car')->getMock(); $this->assertTrue($this->propertyAccessor->isWritable($car, 'axes')); } public function testIsWritableReturnsFalseIfOnlyAdderExists() { $car = $this->getMockBuilder(__CLASS__.'_CarOnlyAdder')->getMock(); $this->assertFalse($this->propertyAccessor->isWritable($car, 'axes')); } public function testIsWritableReturnsFalseIfOnlyRemoverExists() { $car = $this->getMockBuilder(__CLASS__.'_CarOnlyRemover')->getMock(); $this->assertFalse($this->propertyAccessor->isWritable($car, 'axes')); } public function testIsWritableReturnsFalseIfNoAdderNorRemoverExists() { $car = $this->getMockBuilder(__CLASS__.'_CarNoAdderAndRemover')->getMock(); $this->assertFalse($this->propertyAccessor->isWritable($car, 'axes')); } public function testSetValueFailsIfAdderAndRemoverExistButValueIsNotTraversable() { $car = $this->getMockBuilder(__CLASS__.'_Car')->getMock(); $this->propertyAccessor->setValue($car, 'axes', 'Not an array or Traversable'); } } 
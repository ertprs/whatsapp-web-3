<?php
 namespace Symfony\Component\Security\Http\Logout; use Symfony\Component\HttpFoundation\RequestStack; use Symfony\Component\Routing\Generator\UrlGeneratorInterface; use Symfony\Component\Security\Core\Authentication\Token\AnonymousToken; use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface; use Symfony\Component\Security\Csrf\CsrfTokenManagerInterface; class LogoutUrlGenerator { private $requestStack; private $router; private $tokenStorage; private $listeners = array(); private $currentFirewall; public function __construct(RequestStack $requestStack = null, UrlGeneratorInterface $router = null, TokenStorageInterface $tokenStorage = null) { $this->requestStack = $requestStack; $this->router = $router; $this->tokenStorage = $tokenStorage; } public function registerListener($key, $logoutPath, $csrfTokenId, $csrfParameter, CsrfTokenManagerInterface $csrfTokenManager = null) { if (func_num_args() >= 6) { $context = func_get_arg(5); } else { if (__CLASS__ !== get_class($this)) { $r = new \ReflectionMethod($this, __FUNCTION__); if (__CLASS__ !== $r->getDeclaringClass()->getName()) { @trigger_error(sprintf('Method %s() will have a sixth `string $context = null` argument in version 4.0. Not defining it is deprecated since 3.3.', __METHOD__), E_USER_DEPRECATED); } } $context = null; } $this->listeners[$key] = array($logoutPath, $csrfTokenId, $csrfParameter, $csrfTokenManager, $context); } public function getLogoutPath($key = null) { return $this->generateLogoutUrl($key, UrlGeneratorInterface::ABSOLUTE_PATH); } public function getLogoutUrl($key = null) { return $this->generateLogoutUrl($key, UrlGeneratorInterface::ABSOLUTE_URL); } public function setCurrentFirewall($key, $context = null) { $this->currentFirewall = array($key, $context); } private function generateLogoutUrl($key, $referenceType) { list($logoutPath, $csrfTokenId, $csrfParameter, $csrfTokenManager) = $this->getListener($key); if (null === $logoutPath) { throw new \LogicException('Unable to generate the logout URL without a path.'); } $parameters = null !== $csrfTokenManager ? array($csrfParameter => (string) $csrfTokenManager->getToken($csrfTokenId)) : array(); if ('/' === $logoutPath[0]) { if (!$this->requestStack) { throw new \LogicException('Unable to generate the logout URL without a RequestStack.'); } $request = $this->requestStack->getCurrentRequest(); $url = UrlGeneratorInterface::ABSOLUTE_URL === $referenceType ? $request->getUriForPath($logoutPath) : $request->getBaseUrl().$logoutPath; if (!empty($parameters)) { $url .= '?'.http_build_query($parameters); } } else { if (!$this->router) { throw new \LogicException('Unable to generate the logout URL without a Router.'); } $url = $this->router->generate($logoutPath, $parameters, $referenceType); } return $url; } private function getListener($key) { if (null !== $key) { if (isset($this->listeners[$key])) { return $this->listeners[$key]; } throw new \InvalidArgumentException(sprintf('No LogoutListener found for firewall key "%s".', $key)); } if (null !== $this->tokenStorage) { $token = $this->tokenStorage->getToken(); if ($token instanceof AnonymousToken) { throw new \InvalidArgumentException('Unable to generate a logout url for an anonymous token.'); } if (null !== $token && method_exists($token, 'getProviderKey')) { $key = $token->getProviderKey(); if (isset($this->listeners[$key])) { return $this->listeners[$key]; } } } list($key, $context) = $this->currentFirewall; if (isset($this->listeners[$key])) { return $this->listeners[$key]; } foreach ($this->listeners as $listener) { if (isset($listener[4]) && $context === $listener[4]) { return $listener; } } throw new \InvalidArgumentException('Unable to find the current firewall LogoutListener, please provide the provider key manually.'); } } 